<?xml version="1.0"
      encoding="UTF-8"?>
<?xml-stylesheet href="ext/atom.css"
                 type="text/css"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://gholk.github.io/</id>
  <updated>2018-12-03T15:31:35.929Z</updated>
  <icon>http://gholk.github.io/ext/icon.png</icon>
  <title>靜態試驗場 mblog</title>
  <subtitle>你的瀏覽器就是我的實驗場 mblog is for meta bloging</subtitle>
  <link rel="self" type="application/atom+xml" href="http://gholk.github.io/atom.xml"/>
  <link rel="alternate" type="text/html" href="http://gholk.github.io/"/>
  <author>
    <name>gholk</name>
    <uri>http://github.com/GHolk/</uri>
    <email>85619andy@gmail.com</email>
  </author>
  <category term="web"/>
  <category term="linux"/>
  <category term="programming"/>
  <category term="blog"/>
  <category term="ncku"/>
  <category term="taiwan"/>
  <generator uri="https://cheerio.js.org/">cheerio</generator>


<entry>
<id>http://gholk.github.io/secret-reader.html#auto-decrypt-if-password-set</id>
<title>解密閱讀器</title>
<published>2018-12-02T08:08:19.157Z</published>
<updated>2018-12-03T15:31:35.925Z</updated>
<link rel="alternate" type="text/html" href="http://gholk.github.io/secret-reader.html#auto-decrypt-if-password-set"/>
<summary type="html">&lt;pre class=&quot;diff&quot;&gt;@@ -121,6 +121,7 @@ loadOpenpgp.then(openpgp =&gt; {
                 const node = this.getFormName(name)
                 if (node) node.value = value
             }
+            if (goption[&apos;pgp-password&apos;]) this.decryptForm()
         }
     }
     secretReader.loadQueryString()
&lt;/pre&gt;</summary>
<category term="encrypt"/>
<category term="blog"/>
<content type="html">&lt;h1 id=&quot;解密閱讀器&quot;&gt;解密閱讀器&lt;/h1&gt;
&lt;p&gt;用來讀全篇 pgp 加密的文章。
需要載入 openpgpjs，流量會稍大。&lt;/p&gt;
&lt;form&gt;
&lt;label&gt;
filepath
&lt;input name=&quot;file-path&quot; type=&quot;text&quot;&gt;
&lt;/label&gt;

&lt;label&gt;
password
&lt;input name=&quot;pgp-password&quot; type=&quot;password&quot;&gt;
&lt;/label&gt;

&lt;label&gt;
pgp private key
&lt;textarea name=&quot;pgp-private-key&quot;&gt;&lt;/textarea&gt;
&lt;/label&gt;

&lt;button type=&quot;button&quot; onclick=&quot;secretReader.decryptForm()&quot;&gt;decrypt&lt;/button&gt;

&lt;output name=&quot;plain-text&quot;&gt;&lt;/output&gt;
&lt;/form&gt;

&lt;style&gt;
  output {
    white-space: pre-wrap;
  }
  label, output, textarea {
    display: block;
  }
&lt;/style&gt;

&lt;script src=&quot;ext/decrypt-post.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
var secretReader
loadOpenpgp.then(openpgp =&gt; {
    secretReader = {
        openpgp,
        form: document.querySelector(&apos;form&apos;),
        getFormName(name) {
            return this.form.elements[name]
        },
        async fetchEncryptUint8Array(path) {
            if (!path) path = this.getFormName(&apos;file-path&apos;).value
            const response = await fetch(path)
            const arrayBuffer = await response.arrayBuffer()
            return new Uint8Array(arrayBuffer)
        },
        async decrypt(binary, type, key) {
            const stream = false
            const message = this.openpgp.message.read(binary, stream)
            let typename
            if (type == &apos;privateKey&apos;) typename = &apos;privateKeys&apos;
            else typename = &apos;passwords&apos;
            const plain = await this.openpgp.decrypt({
                message, [typename]: key
            })
            return plain.data
        },
        async decryptForm() {
            const password = this.getFormName(&apos;pgp-password&apos;).value
            const armorPrivateKey = this.getFormName(&apos;pgp-private-key&apos;).value
            let type
            let key
            if (armorPrivateKey) {
                const privateKey = await this.openpgp.key.readArmored(armorPrivateKey)
                try {
                    await privateKey.keys[0].decrypt(password)
                }
                catch (privateKeyDecryptError) {
                    alert(&apos;private key password wrong&apos;)
                    throw privateKeyDecryptError
                }
                type = &apos;privateKey&apos;
                key = privateKey.keys[0]
            }
            else {
                type = &apos;password&apos;
                key = password
            }

            const path = this.getFormName(&apos;file-path&apos;).value
            let binary
            try {
                binary = await this.fetchEncryptUint8Array(path)
            }
            catch (fetchFileError) {
                const filepath = this.getFormName(&apos;file-path&apos;).value
                alert(`file &quot;${filepath}&quot; not exist`)
                throw fetchFileError
            }

            let plain
            try {
                plain = await this.decrypt(binary, type, key)
            }
            catch (decryptError) {
                alert(&apos;wrong pgp key&apos;)
                throw decryptError
            }
            this.outputResult(path, plain)
        },
        outputResult(path, plain) {
            if (/\.html?\.gpg$/.test(path)) this.outputReslutHtml(plain)
            else this.getFormName(&apos;plain-text&apos;).textContent = plain
        },
        outputReslutHtml(html) {
            const iframe = document.createElement(&apos;iframe&apos;)
            const output = this.getFormName(&apos;plain-text&apos;)
            output.textContent = &apos;&apos;
            output.appendChild(iframe)
            iframe.contentDocument.write(html)
            iframe.contentDocument.close()
        },
        loadQueryString() {
            for (const [name, value] of Object.entries(goption)) {
                const node = this.getFormName(name)
                if (node) node.value = value
            }
            if (goption[&apos;pgp-password&apos;]) this.decryptForm()
        }
    }
    secretReader.loadQueryString()
})
&lt;/script&gt;
</content>
</entry><entry>
<id>http://gholk.github.io/secret-reader.html#support-html-format</id>
<title>解密閱讀器</title>
<published>2018-12-02T08:08:19.157Z</published>
<updated>2018-12-03T14:42:54.125Z</updated>
<link rel="alternate" type="text/html" href="http://gholk.github.io/secret-reader.html#support-html-format"/>
<summary type="html">
如果檔名以 `*.html.gpg` 結尾，將判定為 html ，
在 iframe 中展示完整的 html 。</summary>
<category term="encrypt"/>
<category term="blog"/>
<content type="html">&lt;h1 id=&quot;解密閱讀器&quot;&gt;解密閱讀器&lt;/h1&gt;
&lt;p&gt;用來讀全篇 pgp 加密的文章。
需要載入 openpgpjs，流量會稍大。&lt;/p&gt;
&lt;form&gt;
&lt;label&gt;
filepath
&lt;input name=&quot;file-path&quot; type=&quot;text&quot;&gt;
&lt;/label&gt;

&lt;label&gt;
password
&lt;input name=&quot;pgp-password&quot; type=&quot;password&quot;&gt;
&lt;/label&gt;

&lt;label&gt;
pgp private key
&lt;textarea name=&quot;pgp-private-key&quot;&gt;&lt;/textarea&gt;
&lt;/label&gt;

&lt;button type=&quot;button&quot; onclick=&quot;secretReader.decryptForm()&quot;&gt;decrypt&lt;/button&gt;

&lt;output name=&quot;plain-text&quot;&gt;&lt;/output&gt;
&lt;/form&gt;

&lt;style&gt;
  output {
    white-space: pre-wrap;
  }
  label, output, textarea {
    display: block;
  }
&lt;/style&gt;

&lt;script src=&quot;ext/decrypt-post.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
var secretReader
loadOpenpgp.then(openpgp =&gt; {
    secretReader = {
        openpgp,
        form: document.querySelector(&apos;form&apos;),
        getFormName(name) {
            return this.form.elements[name]
        },
        async fetchEncryptUint8Array(path) {
            if (!path) path = this.getFormName(&apos;file-path&apos;).value
            const response = await fetch(path)
            const arrayBuffer = await response.arrayBuffer()
            return new Uint8Array(arrayBuffer)
        },
        async decrypt(binary, type, key) {
            const stream = false
            const message = this.openpgp.message.read(binary, stream)
            let typename
            if (type == &apos;privateKey&apos;) typename = &apos;privateKeys&apos;
            else typename = &apos;passwords&apos;
            const plain = await this.openpgp.decrypt({
                message, [typename]: key
            })
            return plain.data
        },
        async decryptForm() {
            const password = this.getFormName(&apos;pgp-password&apos;).value
            const armorPrivateKey = this.getFormName(&apos;pgp-private-key&apos;).value
            let type
            let key
            if (armorPrivateKey) {
                const privateKey = await this.openpgp.key.readArmored(armorPrivateKey)
                try {
                    await privateKey.keys[0].decrypt(password)
                }
                catch (privateKeyDecryptError) {
                    alert(&apos;private key password wrong&apos;)
                    throw privateKeyDecryptError
                }
                type = &apos;privateKey&apos;
                key = privateKey.keys[0]
            }
            else {
                type = &apos;password&apos;
                key = password
            }

            const path = this.getFormName(&apos;file-path&apos;).value
            let binary
            try {
                binary = await this.fetchEncryptUint8Array(path)
            }
            catch (fetchFileError) {
                const filepath = this.getFormName(&apos;file-path&apos;).value
                alert(`file &quot;${filepath}&quot; not exist`)
                throw fetchFileError
            }

            let plain
            try {
                plain = await this.decrypt(binary, type, key)
            }
            catch (decryptError) {
                alert(&apos;wrong pgp key&apos;)
                throw decryptError
            }
            this.outputResult(path, plain)
        },
        outputResult(path, plain) {
            if (/\.html?\.gpg$/.test(path)) this.outputReslutHtml(plain)
            else this.getFormName(&apos;plain-text&apos;).textContent = plain
        },
        outputReslutHtml(html) {
            const iframe = document.createElement(&apos;iframe&apos;)
            const output = this.getFormName(&apos;plain-text&apos;)
            output.textContent = &apos;&apos;
            output.appendChild(iframe)
            iframe.contentDocument.write(html)
            iframe.contentDocument.close()
        },
        loadQueryString() {
            for (const [name, value] of Object.entries(goption)) {
                const node = this.getFormName(name)
                if (node) node.value = value
            }
        }
    }
    secretReader.loadQueryString()
})
&lt;/script&gt;
</content>
</entry>

<entry>
<id>http://gholk.github.io/secret-reader.html</id>
<title>解密閱讀器</title>
<published>2018-12-02T08:08:19.157Z</published>
<updated>2018-12-02T09:43:40.760Z</updated>
<link rel="alternate" type="text/html" href="http://gholk.github.io/secret-reader.html"/>
<summary type="html">用來讀全篇 pgp 加密的文章。
需要載入 openpgpjs，流量會稍大。</summary>
<category term="encrypt"/>
<category term="blog"/>
<content type="html">&lt;h1 id=&quot;解密閱讀器&quot;&gt;解密閱讀器&lt;/h1&gt;
&lt;p&gt;用來讀全篇 pgp 加密的文章。
需要載入 openpgpjs，流量會稍大。&lt;/p&gt;
&lt;form&gt;
&lt;label&gt;
filepath
&lt;input name=&quot;file-path&quot; type=&quot;text&quot;&gt;
&lt;/label&gt;

&lt;label&gt;
password
&lt;input name=&quot;pgp-password&quot; type=&quot;password&quot;&gt;
&lt;/label&gt;

&lt;label&gt;
pgp private key
&lt;textarea name=&quot;pgp-private-key&quot;&gt;&lt;/textarea&gt;
&lt;/label&gt;

&lt;button type=&quot;button&quot; onclick=&quot;secretReader.decryptForm()&quot;&gt;decrypt&lt;/button&gt;

&lt;output name=&quot;plain-text&quot;&gt;&lt;/output&gt;
&lt;/form&gt;

&lt;style&gt;
  output {
    white-space: pre-wrap;
  }
  label, output, textarea {
    display: block;
  }
&lt;/style&gt;

&lt;script src=&quot;ext/decrypt-post.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
var secretReader
loadOpenpgp.then(openpgp =&gt; {
    secretReader = {
        openpgp,
        form: document.querySelector(&apos;form&apos;),
        getFormName(name) {
            return this.form.elements[name]
        },
        async fetchEncryptUint8Array(path) {
            if (!path) path = this.getFormName(&apos;file-path&apos;).value
            const response = await fetch(path)
            const arrayBuffer = await response.arrayBuffer()
            return new Uint8Array(arrayBuffer)
        },
        async decrypt(binary, type, key) {
            const stream = false
            const message = this.openpgp.message.read(binary, stream)
            let typename
            if (type == &apos;privateKey&apos;) typename = &apos;privateKeys&apos;
            else typename = &apos;passwords&apos;
            const plain = await this.openpgp.decrypt({
                message, [typename]: key
            })
            return plain.data
        },
        async decryptForm() {
            const password = this.getFormName(&apos;pgp-password&apos;).value
            const armorPrivateKey = this.getFormName(&apos;pgp-private-key&apos;).value
            let type
            let key
            if (armorPrivateKey) {
                const privateKey = await this.openpgp.key.readArmored(armorPrivateKey)
                try {
                    await privateKey.keys[0].decrypt(password)
                }
                catch (privateKeyDecryptError) {
                    alert(&apos;private key password wrong&apos;)
                    throw privateKeyDecryptError
                }
                type = &apos;privateKey&apos;
                key = privateKey.keys[0]
            }
            else {
                type = &apos;password&apos;
                key = password
            }

            let binary
            try {
                binary = await this.fetchEncryptUint8Array()
            }
            catch (fetchFileError) {
                const filepath = this.getFormName(&apos;file-path&apos;).value
                alert(`file &quot;${filepath}&quot; not exist`)
                throw fetchFileError
            }

            let plain
            try {
                plain = await this.decrypt(binary, type, key)
            }
            catch (decryptError) {
                alert(&apos;wrong pgp key&apos;)
                throw decryptError
            }
            this.getFormName(&apos;plain-text&apos;).textContent = plain
        },
        loadQueryString() {
            for (const [name, value] of Object.entries(goption)) {
                const node = this.getFormName(name)
                if (node) node.value = value
            }
        }
    }
    secretReader.loadQueryString()
})
&lt;/script&gt;
</content>
</entry>
<entry>
<id>http://gholk.github.io/online-web-chat-room.html</id>
<title>嵌入式的線上即時聊天室</title>
<published>2018-01-02T14:14:13.264Z</published>
<updated>2018-01-02T16:10:25.571Z</updated>
<link rel="alternate" type="text/html" href="http://gholk.github.io/online-web-chat-room.html"/>
<summary>很久以前在 fc2 看過類似的東西，覺得不錯，
前幾天又在 //blog.user.today 看到，
就決定自己裝一個。最後選了 cbox 這個平台。</summary>
<category term="blog"/>
<category term="disqus"/>
<category term="聊天"/>
<category term="留言"/>
<category term="cbox"/>
</entry>
<entry>
<id>http://gholk.github.io/comment.html</id>
<title> 留言板</title>
<published>2017-11-06T05:07:50.771Z</published>
<link rel="alternate" type="text/html" href="http://gholk.github.io/comment.html"/>
<summary>
    本網站的通用留言板。
雖然每篇文章都有留言板，
但如果不知道要留在哪篇文章，
就留在這裡吧。留言可以用其它平台上你慣用的帳號登入，
如果不想登入也可以匿名評論。
    </summary>
<category term="留言"/>
<category term="匿名"/>
<category term="blog"/>
</entry>

</feed>
